- [Вопросы](#вопросы)
- [Соотнесение описания текущего решения и кода приложения](#соотнесение-описания-текущего-решения-и-кода-приложения)
- [Анализ задания 1](#анализ-задания-1)
- [Event storming](#event-storming)
- [DDD to be системы](#ddd-to-be-системы)

## Вопросы

1. Какую роль выполняет сервис `temperature-api` в текущем решении, которое описано в задании? Правильно ли я понимаю, что это некий gateway для взаимодействия с физическими устройствами датчиков температуры?
2. Как сервис `temperature-api` выбирает устройство для определение темпратуры по локации?
3. Почему в текущем решении система описана как монолитное приложение, если в нем уже есть два отдельных сервиса (`smart_home` и `temperature-api`)?
4. Правильно ли я понимаю, что текущее решение это on-premise продукт, которое работает в инфраструктуре пользователя, а не SaaS решение? Если нет, то почему в текущем решении нет никакой сущности пользователя и механизмов аутентификации/авторизации?
5. Почему в задании говорится о последовательной обработке запросов, если в сервисе нет никаких механизмов, обеспечивающих это?
6. Почему в заданнии говорится о необходимости остановки приложения для развертывания, если сервис stateless и не требует этого?
7. Достаточно ли показать на диаграмме контекста, что система взаимодействует с датчиками через сервис `temperature-api`? Если нет, то что нужно показать на этой диаграмме?


## Соотнесение описания текущего решения и кода приложения

> Нынешнее приложение компании позволяет только управлять отоплением в доме и проверять температуру.

Этот функционал соотносится с ручками сервиса **smart_home**, а именно следующими:
1. `/api/v1/sensors/temperature/:location` &mdash; проверка температуры по локации. Сама ручка ходит в вспомогательный сервис **temperature-api**, который предлагается реализовать в задании 5. Мне здесь непонятно что такое локация и почему в эта ручка ходит во внешний сервис по названию этой локации. Я так же посмотрел в **Postman** коллекцию, в которой есть локация *Living Room* в примере запроса создания датчика, но ясности мне это не добавило, так как непонятно откуда вспомогательный сервис **temperature-api** должен знать в какой датчик ему сходить для получения температуры по локации.
2. `/api/v1/sensors` -- получение списка устройств и их данные по температуре. В этой ручке логика мне чуть более понятна, и в текущей реализации она просто использует сервис **temperature-api** как некий шлюз для общения с устройством.
3. `/api/v1/sensors/:id` -- аналогично предыдущей ручке, только для одного устройства.

> Каждая установка сопровождается выездом специалиста по подключению системы отопления в доме к текущей версии системы.

Этот функционал соотносится со следующими ручками сервиса **smart_home**:

1. `POST /api/v1/sensors` -- создание нового устройства. Здесь вроде бы все понятно, за исключением того почему этой ручкой не может пользоваться конечный пользователь через UI.
2. `DELETE /api/v1/sensors/:id` -- удаление устройства. Аналогично первому пункту.
3. `PUT /api/v1/sensors/:id` -- обновление устройства. Аналогично первого пункту.

> Архитектура приложения представляет из себя монолит на Go с СУБД Postgres. Всё синхронно. Никаких асинхронных вызовов, микросервисов и реактивного взаимодействия в системе нет. Всё управление идёт от сервера к датчику. Данные о температуре также получаются через запрос от сервера к датчику.

Здесь я, к сожалению, не очень понимаю как описание соотносится с кодом, потому что у нас есть вспомогательный сервис **temperature-api**, который судя по всему отвечает за интеграцию с устройствами. Поэтому для меня вся система уже не монолит, а распределенное приложение из двух сервисов. Помимо этого, в системе уже заложено API для обновления и хранения текущей температуры в БД, что опять таки не совсем соотносится с описанием.

> Самостоятельно подключить свой датчик к системе пользователь не может.

Это ограничение как-будто бы подразумевает, что конечный пользователь не имеет доступа к API сервиса **smart_home** и не может создавать, удалять или обновлять устройства. Но в текущей реализации API этого ограничения нет.


## Анализ задания 1

>Задание 1. Анализ и планирование
>
>Прежде чем проектировать новую систему, необходимо досконально разобраться с тем, что есть. Вам нужно изучить текущее монолитное приложение, понять его сильные и слабые стороны, а также проанализировать, как принципы Domain-Driven Design (DDD) могут быть применены для построения новой архитектуры.

>1. Изучите функциональность монолитного приложения:
>
>Управление отоплением. Пользователи могут удалённо включать/выключать отопление в своих домах.
>
>Мониторинг температуры. Система получает данные о температуре с датчиков, установленных в домах. Пользователи могут просматривать текущую температуру в своих домах через веб-интерфейс.

В актуальном коде приложения я не нашел логики, которая отвечала бы за управление устройством. Возможно за это отвечает сервис **temperature-api**, слушая изменения в БД. Но так как этот сервис не реализован, это только догадки.

>2. роанализируйте архитектуру монолитного приложения:
>
>Язык программирования: Go
>
>База данных: PostgreSQL
>
>Архитектура: Монолитная, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в рамках одного приложения.
>
>Взаимодействие: Синхронное, запросы обрабатываются последовательно.
>
>Масштабируемость: Ограничена, так как монолит сложно масштабировать по частям.
>
>Развертывание: Требует остановки всего приложения.

В текущем решение присутствует два отдельных сервиса, что расходится с описанием задания. Так же непонятно, что подразумевается под синхронным взаимодействием и последовательной обработкой, так как сервис **smart_home** реализован на и там нет никаких механизмов, влекщих за собой последовательность обработки запросов. Описание почему-то говорти о требовании остановки приложения для развертывания, но само приложение stateless и не требует этого.

> 3. Определите домены и границы контекстов: домен «Управление Устройствами» и так далее.

> 4. Визуализируйте контекст системы. Создайте диаграмму контекста (Context diagram) в модели C4 с помощью PlantUML. Диаграмма должна наглядно показывать, как монолитное приложение взаимодействует с внешним миром (пользователи, датчики).

Исходя из текущего решения, взаимодействие системы с датчиками реализуется через вспомогательный сервис **temperature-api**.

## Event storming

Текущее решение:

1. Система отопления подключена/отключена (результат работы специлиста)
2. Заданная температура изменена
3. Предоставлена текущая температура

Целевое решение:

1. Система отопления подключена/отключена
2. Система управления светом подключена/отключена
3. Система управления автоматических вороот подключена/отключена
4. Система видеонаблюдения подключена/отключена
5. Заданная температура изменена
6. Предоставлена текущая температура
8. Заданное состояние света изменено
9. Предоставлено состояние света (включено/выключено)
10. Заданное состояние ворот изменено
11. Предоставлено состояние ворот (открыто/закрыто)
12. Предоставлено видео с камеры
13. Настроен сценарий работы устройства (???)
14. Предоставлена телеметрия устройства (???)

## DDD to be системы

Домены:
1. Автоматизация дома
   1. Создание сценариев автоматизации
   2. Выполнение сценариев
2. Управление отоплением
   1. Установка целевой температуры
   2. Автоматизация включения/выключения отопления
3. Управление устройствами
   1. Регистрация новых датчиков
   2. Обновление настроек датчиков
   3. Деактивация и удаление датчиков
   4. Хранение конфигураций устройств
4. Мониторинг устройств
   1. Сбор данных со всех типов устройств
   2. Просмотрр и хранение данных
5. Управление освещением
   1. Включение/выключение света
   2. Регулировка яркости
6. Управление воротами
   1. Открытие/закрытие ворот
7. Видеонаблюдение
   1. Просмотр видео с камер
   2. Запись и хранение видео
8. Интеграция с устройствами
   1. Получение данных с физических устройств
   2. Абстракция протокола связи с устройствами
9. Пользователи и аутентификация
    1. Регистрация и управление пользователями
    2. Аутентификация и авторизация

Контексты:
1. Контекст автоматизации
2. Управление состояние устройств
3. Управление устройствами
4. Контекст мониторинга устройств
5. Контекст видеонаблюдения
6. Контекст интеграции с устройствами
7. Контекст пользователя и аутентификации
